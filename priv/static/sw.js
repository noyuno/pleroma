var __wpo = {"assets":{"main":["/packs/base_polyfills.js","/packs/extra_polyfills.js","/packs/features/compose.js","/packs/modals/onboarding_modal.js","/packs/emoji_picker.js","/packs/features/notifications.js","/packs/features/account_timeline.js","/packs/features/home_timeline.js","/packs/features/public_timeline.js","/packs/features/direct_timeline.js","/packs/features/community_timeline.js","/packs/features/favourited_statuses.js","/packs/features/list_timeline.js","/packs/features/hashtag_timeline.js","/packs/features/following.js","/packs/features/followers.js","/packs/features/status.js","/packs/features/account_gallery.js","/packs/features/blocks.js","/packs/features/follow_requests.js","/packs/features/reblogs.js","/packs/features/favourites.js","/packs/features/getting_started.js","/packs/features/keyboard_shortcuts.js","/packs/features/generic_not_found.js","/packs/features/list_editor.js","/packs/status/media_gallery.js","/packs/share.js","/packs/about.js","/packs/application.js","/packs/public.js","/packs/mailer.js","/packs/contrast.js","/packs/default.js","/packs/admin.js","/packs/common.js","/packs/common.css","/packs/mailer.css","/packs/default.css","/packs/contrast.css","/packs/manifest.json"],"additional":["/emoji/1f602.svg","/emoji/sheet.png"],"optional":["/packs/locale_zh-TW.js","/packs/locale_zh-HK.js","/packs/locale_zh-CN.js","/packs/locale_uk.js","/packs/locale_tr.js","/packs/locale_th.js","/packs/locale_sv.js","/packs/locale_sr.js","/packs/locale_sr-Latn.js","/packs/locale_sk.js","/packs/locale_ru.js","/packs/locale_pt.js","/packs/locale_pt-BR.js","/packs/locale_pl.js","/packs/locale_oc.js","/packs/locale_no.js","/packs/locale_nl.js","/packs/locale_ko.js","/packs/locale_ja.js","/packs/locale_it.js","/packs/locale_io.js","/packs/locale_id.js","/packs/locale_hy.js","/packs/locale_hu.js","/packs/locale_hr.js","/packs/locale_he.js","/packs/locale_gl.js","/packs/locale_fr.js","/packs/locale_fi.js","/packs/locale_fa.js","/packs/locale_eu.js","/packs/locale_es.js","/packs/locale_eo.js","/packs/locale_en.js","/packs/locale_de.js","/packs/locale_ca.js","/packs/locale_bg.js","/packs/locale_ar.js","/packs/roboto-italic-webfont-50efdad8c62f5f279e3f4f1f63a4f9bc.woff2","/packs/roboto-bold-webfont-f633cb5c651ba4d50791e1adf55d3c18.woff2","/packs/roboto-medium-webfont-69c55fc2fe77d38934ea98dc31642ce6.woff2","/packs/roboto-regular-webfont-3ec24f953ed5e859a6402cb3c030ea8b.woff2","/packs/fontawesome-webfont-af7ae505a9eed503f8b8e6982036873e.woff2","/packs/robotomono-regular-webfont-6c1ce30b90ee993b22618ec489585594.woff2","/packs/Montserrat-Regular-080422d4c1328f3407818d25c86cce51.woff2","/packs/void-65dfe5bd31335a5b308d36964d320574.png","/packs/reticle-7d7ce959271e5ff1193fb32cff90ea56.png","/packs/elephant-fren-d16fd77f9a9387e7d146b5f9d4dc1e7f.png","/packs/icon_cached-98a757f1d9e93652742be43c22f46287.png","/packs/icon_done-12b87c12f915597dccbd2ca4d7167ba4.png","/packs/icon_email-738c89662d6640f5e6539151023d049a.png","/packs/icon_file_download-e5c29678f3a639e1e62374911d85e1d0.png","/packs/icon_grade-3ec67253b37908d2ab783f7225f20682.png","/packs/icon_lock_open-0bfd71a52eb3f34934edd59088b559fb.png","/packs/icon_person_add-e2c6b660f6e1c95785d8d2bfa7a823af.png","/packs/icon_reply-4f6ada7a0b886b084706a484753a0ff0.png","/packs/logo_full-5c51cffe1fcb8225ae02400d6a7e7077.png","/packs/logo_transparent-6f79eeb2c38ec2d12ed4d978322457d6.png","/packs/preview-9a17d32fc48369e8ccd910a75260e67d.jpg","/packs/elephant_ui_plane-e3f2d57c12c376e189c274cbe81af8dd.svg","/packs/elephant_ui_disappointed-8864342480c3612e3061702851d3a798.svg","/packs/elephant_ui_greeting-475430963d0b00fe82b07b17857ebf6c.svg","/packs/elephant_ui_working-2e653cc278c2ac871c23aeb10de1c0e2.svg","/packs/icon_cached-108e30d96e1d5152be7fe2978bcdfe14.svg","/packs/icon_done-dba357bfbba455428787fefc655ce120.svg","/packs/icon_email-1346985c7aaceb601b0d4257133254f4.svg","/packs/icon_file_download-4b5c054e76b0df3cbbc851854cd10c3c.svg","/packs/icon_grade-8e81b8e88c2b5834347a2a226c65d440.svg","/packs/icon_lock_open-c9627928caaaa505ac7de2a64bd065ec.svg","/packs/icon_person_add-5c56ef10b9e99e77a44d89041f4b77b5.svg","/packs/icon_reply-b5e28e1fe6acd4ec003e643e947f1c4a.svg","/packs/logo-fe5141d38a25f50068b4c69b77ca1ec8.svg","/packs/logo_alt-6090911445f54a587465e41da77a6969.svg","/packs/logo_full-96e7a97fe469f75a23a74852b2478fa3.svg","/packs/logo_transparent-6900bab180aa3a46c34425e5367a218f.svg"]},"externals":["/emoji/1f602.svg","/emoji/sheet.png"],"hashesMap":{"8aadd54157395376ea8c22827bde88e67f31358e":"/packs/roboto-italic-webfont-50efdad8c62f5f279e3f4f1f63a4f9bc.woff2","e2fc71044647b6edf7a3ba41429d5d626e63710a":"/packs/roboto-bold-webfont-f633cb5c651ba4d50791e1adf55d3c18.woff2","b66f9a200f8671202198f0238b4729e127bc0dac":"/packs/roboto-medium-webfont-69c55fc2fe77d38934ea98dc31642ce6.woff2","74f352b40a57789750d3c738c710a82cdb0f254a":"/packs/roboto-regular-webfont-3ec24f953ed5e859a6402cb3c030ea8b.woff2","d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c":"/packs/fontawesome-webfont-af7ae505a9eed503f8b8e6982036873e.woff2","1e149b7d5f1c5a5c4971cb523450118b1d50ed47":"/packs/robotomono-regular-webfont-6c1ce30b90ee993b22618ec489585594.woff2","c6aade94b414951dc75e41b6f30fc1fa93bf89fb":"/packs/Montserrat-Regular-080422d4c1328f3407818d25c86cce51.woff2","7e2065071fefe6d54f64b821bf575a0ab49b92c0":"/packs/void-65dfe5bd31335a5b308d36964d320574.png","f7e7808e34f32df8859ac9cef991858df4fc0bba":"/packs/reticle-7d7ce959271e5ff1193fb32cff90ea56.png","8523aa7b16b029770170cc12026e7c7d172d626d":"/packs/elephant_ui_plane-e3f2d57c12c376e189c274cbe81af8dd.svg","027d2ab934afd67b404426234750c08b516ec223":"/packs/elephant-fren-d16fd77f9a9387e7d146b5f9d4dc1e7f.png","2523b7002bda93c12af3b4b7f4d7a35fd52faf41":"/packs/elephant_ui_disappointed-8864342480c3612e3061702851d3a798.svg","2dace1e38e0d159660c56d838ad2ce22c0184661":"/packs/elephant_ui_greeting-475430963d0b00fe82b07b17857ebf6c.svg","42a8fc2f0526540979583534ec331a2d28d2575e":"/packs/elephant_ui_working-2e653cc278c2ac871c23aeb10de1c0e2.svg","22fac75a796b2bd2c6872cbd8d14bd325b00bb64":"/packs/icon_cached-108e30d96e1d5152be7fe2978bcdfe14.svg","e9cea6fd6e8034f60e0358a15956490831c66b03":"/packs/icon_done-dba357bfbba455428787fefc655ce120.svg","17604ec5d343bc1aee070a2197dae8fd78bdccef":"/packs/icon_email-1346985c7aaceb601b0d4257133254f4.svg","e4a88b85b09c072041e89acaa22ec362ece97f27":"/packs/icon_file_download-4b5c054e76b0df3cbbc851854cd10c3c.svg","75a26256446662fb331fd42b9849dfff235364d5":"/packs/icon_grade-8e81b8e88c2b5834347a2a226c65d440.svg","7a534f4811adb70a796a285fb70b93c87a9f4b94":"/packs/icon_lock_open-c9627928caaaa505ac7de2a64bd065ec.svg","08ef53f9228b3d24f2801ba942fc842599c39e34":"/packs/icon_person_add-5c56ef10b9e99e77a44d89041f4b77b5.svg","ad9a0479341f3a93a83c7cadab091569e459076c":"/packs/icon_reply-b5e28e1fe6acd4ec003e643e947f1c4a.svg","aa75bce521938954706802c15e393ea05663e5e0":"/packs/logo-fe5141d38a25f50068b4c69b77ca1ec8.svg","f573db9e5698b7a3541880875c3ce88fe03ebee2":"/packs/logo_alt-6090911445f54a587465e41da77a6969.svg","3b339fcffc64574bca7cd2521e25bfbea8c3cbbf":"/packs/logo_full-96e7a97fe469f75a23a74852b2478fa3.svg","12520e03b958c73d94a1f19644ca4d0b79c6505d":"/packs/logo_transparent-6900bab180aa3a46c34425e5367a218f.svg","dc0b5a8d2d7e67f84d37635137610c6c6d937058":"/packs/icon_cached-98a757f1d9e93652742be43c22f46287.png","58f810df15baa9109f9db7f800e31c0d011e6f0d":"/packs/icon_done-12b87c12f915597dccbd2ca4d7167ba4.png","828ed8086eacb6622609e9992950998ce0a1579b":"/packs/icon_email-738c89662d6640f5e6539151023d049a.png","c60492c5ceea92a0acb138f20e0a33dd1e553f6b":"/packs/icon_file_download-e5c29678f3a639e1e62374911d85e1d0.png","b60349291b7d31e9aa78b94aed0f6ce07171096f":"/packs/icon_grade-3ec67253b37908d2ab783f7225f20682.png","d80b4dd1135df4803cddc1c1f6646dd7fc601367":"/packs/icon_lock_open-0bfd71a52eb3f34934edd59088b559fb.png","3f2c7f54c1073569de3a7312fb9a055723f68898":"/packs/icon_person_add-e2c6b660f6e1c95785d8d2bfa7a823af.png","f7717ae34919e3c88a668b5d9426b5fdc868b0de":"/packs/icon_reply-4f6ada7a0b886b084706a484753a0ff0.png","ee2ae924bf02960749696f2c66890780ca321924":"/packs/logo_full-5c51cffe1fcb8225ae02400d6a7e7077.png","2a2ed7e6889f11e00656cb952d0704f762bf05ea":"/packs/logo_transparent-6f79eeb2c38ec2d12ed4d978322457d6.png","361cf83e570038228710feb587738d6b74308e26":"/packs/preview-9a17d32fc48369e8ccd910a75260e67d.jpg","e3a184756690bf81f95ffe5d997c535d5d7a66f1":"/packs/base_polyfills.js","2b4ead0ddab7082d434f9ec41b2f617d61c26367":"/packs/extra_polyfills.js","edb3978902d1841c3d16e506e4326ef98b5cd30b":"/packs/features/compose.js","d085dd4dabad537781cd2a94680496b17dc7e470":"/packs/modals/onboarding_modal.js","6861c8e3953820dda361be3196f44a1319440871":"/packs/emoji_picker.js","129046ecf7079ecb3fd66456d77fa07e9d9eaa86":"/packs/features/notifications.js","c7f6485c95421a9c0530cf428cda8ca01a167fb8":"/packs/features/account_timeline.js","d2d8766c1f64886f78d49651f10d410cc8d84b1e":"/packs/features/home_timeline.js","18e26934125c6d85846a15cfe45928d109d38cbd":"/packs/features/public_timeline.js","10116c5e1574cebab588afa7f9d2f4334f4de903":"/packs/features/direct_timeline.js","4aa32ec875609601959c3bd89a2f90272028e5e9":"/packs/features/community_timeline.js","31cb83fa216e373bc4b239f15fd56b636beeb82d":"/packs/features/favourited_statuses.js","e99c7b69145de7ee39d784a1d2dbc776ea179ccf":"/packs/features/list_timeline.js","46a611a7d38fcf8d8c72ef6815cd403221f9a5cd":"/packs/features/hashtag_timeline.js","7ccf1f63a6ff6f8a4d6b2d21c78bfb5d2b8e1ccf":"/packs/features/following.js","f3ddd37f7271657e8ce5a81f9bd9c31339676e03":"/packs/features/followers.js","ad4a5e49918b279f7d7eba1267cff40b0deadf22":"/packs/features/status.js","195238325de5216d9900a03e3c0e496d9959d2b3":"/packs/features/account_gallery.js","e21104c8dcc7817fa154ac70e2ff107cfbe68383":"/packs/features/blocks.js","89ac329abded23753284bfd768fb70252eb7c1d2":"/packs/features/follow_requests.js","9a6038992acc2ce956edd1d2e21621bd8d7f4b59":"/packs/features/reblogs.js","c3c2d07f8c4e5c8281d97bbd58c6685ebdb3e335":"/packs/features/favourites.js","63ac90b57af067eaa0e92463cb56ec33c32f3bb2":"/packs/features/getting_started.js","fcb21b4f66e429ea773d213f541122dce82e36e3":"/packs/features/keyboard_shortcuts.js","82fcf14b3788f008223754b74f9e73661612429f":"/packs/features/generic_not_found.js","1ad9b97b321cd1eb0d6d69d1a69981a627c7d870":"/packs/features/list_editor.js","15c271d876d8f399b1e4ed8443918bfa337dc638":"/packs/status/media_gallery.js","675dde3e32e54fab39990076839aa6a71ffbef49":"/packs/share.js","71ef864cb8edf6095f1c472e89e325659a0aa2b1":"/packs/about.js","995fbcc94db1e05c2c71a025725e4ea18353861d":"/packs/application.js","51ce7e797f8d88772d119600ef9862ef178411af":"/packs/public.js","215d8bf2c6c9719ee9f3f64797c5b7c527709495":"/packs/locale_zh-TW.js","d995904c60025bea436c93485536e57c92ce7ee8":"/packs/locale_zh-HK.js","676dd4e3112d74bb5f8a9916139010b5b80404e2":"/packs/locale_zh-CN.js","3ad3f62e284b9bec31d37b625d43f43c21849a43":"/packs/locale_uk.js","988e80ee936fc98935f6a465b255d0ce7b0c9ce8":"/packs/locale_tr.js","0d4c76e58856d2621e0c4de8055402e0a3527232":"/packs/locale_th.js","ed868db51d7f58cff3d9d94a4a687682234da821":"/packs/locale_sv.js","fec06bd102d19b6ad760e33f363316d0e921dcbc":"/packs/locale_sr.js","17eddc90912d3a0de4ca324a9266c9ab7acc1f65":"/packs/locale_sr-Latn.js","bc538860fa81888f6a6efe71444d8d2cb8b8481c":"/packs/locale_sk.js","314698ccf276b4f7d3b4156830a851e38d3a2730":"/packs/locale_ru.js","97ebf63a2882c1caa0844dc2dda7fa918fb22ed0":"/packs/locale_pt.js","ce764517d189cfee861784a60d9f82753151e695":"/packs/locale_pt-BR.js","9a6cc9170a488bae643db6fa9f57d502a60609d6":"/packs/locale_pl.js","d9ae5aad155435e77d85eb8c8ad4ca2d7f5c7702":"/packs/locale_oc.js","2f21d45e49b30583e4a1ffc8c14935fa3465b26e":"/packs/locale_no.js","c2857b07f23cf0a438cd5404a7cf7bcf645aa7fe":"/packs/locale_nl.js","a09afb0fb314a9abc0fa7888a0fd85f747c83640":"/packs/locale_ko.js","532ca175dccb05de4c23bb0120e198faf976243d":"/packs/locale_ja.js","756fd56f62beedbc7ad8a9620f1b7607237d7f28":"/packs/locale_it.js","a2f18d3ecbd111152fad765005eae04818384a36":"/packs/locale_io.js","916bd81622800f9ef47a32188bff5ed5d3bebe16":"/packs/locale_id.js","35371d63b720167e3575662f4f23bd8b714c460b":"/packs/locale_hy.js","03fa1e78fbd7404a939e69fb5e540037f147fb04":"/packs/locale_hu.js","37e6c7ad7120a803c3626edcf39d30895274d14e":"/packs/locale_hr.js","c622723239d0a3d619161f83a6b7426740860f79":"/packs/locale_he.js","857c58f6c3b493a067d64e80bc2ee198e515d571":"/packs/locale_gl.js","9e687bbda98b7e77df1ffe15e37bd7d02073fc46":"/packs/locale_fr.js","2c78a6574c342416acb411e327e36289cd515b89":"/packs/locale_fi.js","dfc154a8a976bd479db877d2afcd21d36cd8638d":"/packs/locale_fa.js","91f1a1bad06706d789a936de9724fcfa871644c6":"/packs/locale_eu.js","0383dad4e84217f437b7a9e8f1d8355e604d752f":"/packs/locale_es.js","959eacceab18aa337bd86d09d99efc1fc945fee2":"/packs/locale_eo.js","dce61d6b05c59aa8ecd5a206c1f6636ee0ae522f":"/packs/locale_en.js","3a7434396686dd789bf506030fee35f7e6add5c0":"/packs/locale_de.js","f8dba6173f822b166104bcc8dadb461f4b5c3690":"/packs/locale_ca.js","7e4b6d0ab0175b3fb45996a52fbeebb232b9e9d3":"/packs/locale_bg.js","2a16dbeac91d6f19a232108789f01477e34e0565":"/packs/locale_ar.js","c7788189752b401430f3e95d7aecb752b7668a16":"/packs/mailer.js","edfea78acdfc8bee2af786bcdf13a5b804f46b4d":"/packs/contrast.js","98d3eec330b6bb4b5c218be7ebbd7b739f07c1c9":"/packs/default.js","94115e4d664505d7c2d52cd9a955232642443379":"/packs/admin.js","e7ed17337a8b340dea6d7685760d1d8a11f3c082":"/packs/common.js","63d5949a7f9065ed25c771b22883444dc420be1d":"/packs/common.css","2a742852e4241f6de4f33884bf01731c08a3851d":"/packs/mailer.css","b22e10afaa29c9c965d058e9e4be29c4c3ec688d":"/packs/default.css","992f876a8af48e469e91dfdb5c6d5068b98d0e14":"/packs/contrast.css","7a842bcd58bc3540604134c528cdd3cb99b0cc59":"/packs/manifest.json"},"strategy":"changed","responseStrategy":"cache-first","version":"5/16/2018, 10:48:15 AM","name":"webpack-offline:mastodon","pluginVersion":"4.8.4","relativePaths":false};

/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/packs/";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


(function () {
  var waitUntil = ExtendableEvent.prototype.waitUntil;
  var respondWith = FetchEvent.prototype.respondWith;
  var promisesMap = new WeakMap();

  ExtendableEvent.prototype.waitUntil = function (promise) {
    var extendableEvent = this;
    var promises = promisesMap.get(extendableEvent);

    if (promises) {
      promises.push(Promise.resolve(promise));
      return;
    }

    promises = [Promise.resolve(promise)];
    promisesMap.set(extendableEvent, promises);

    // call original method
    return waitUntil.call(extendableEvent, Promise.resolve().then(function processPromises() {
      var len = promises.length;

      // wait for all to settle
      return Promise.all(promises.map(function (p) {
        return p["catch"](function () {});
      })).then(function () {
        // have new items been added? If so, wait again
        if (promises.length != len) return processPromises();
        // we're done!
        promisesMap["delete"](extendableEvent);
        // reject if one of the promises rejected
        return Promise.all(promises);
      });
    }));
  };

  FetchEvent.prototype.respondWith = function (promise) {
    this.waitUntil(promise);
    return respondWith.call(this, promise);
  };
})();;
        'use strict';

if (typeof DEBUG === 'undefined') {
  var DEBUG = false;
}

function WebpackServiceWorker(params, helpers) {
  var loaders = helpers.loaders;
  var cacheMaps = helpers.cacheMaps;

  var strategy = params.strategy;
  var responseStrategy = params.responseStrategy;

  var assets = params.assets;
  var loadersMap = params.loaders || {};

  var hashesMap = params.hashesMap;
  var externals = params.externals;

  // Not used yet
  // const alwaysRevalidate = params.alwaysRevalidate;
  // const ignoreSearch = params.ignoreSearch;
  // const preferOnline = params.preferOnline;

  var CACHE_PREFIX = params.name;
  var CACHE_TAG = params.version;
  var CACHE_NAME = CACHE_PREFIX + ':' + CACHE_TAG;

  var STORED_DATA_KEY = '__offline_webpack__data';

  mapAssets();

  var allAssets = [].concat(assets.main, assets.additional, assets.optional);
  var navigateFallbackURL = params.navigateFallbackURL;
  var navigateFallbackForRedirects = params.navigateFallbackForRedirects;

  self.addEventListener('install', function (event) {
    console.log('[SW]:', 'Install event');

    var installing = undefined;

    if (strategy === 'changed') {
      installing = cacheChanged('main');
    } else {
      installing = cacheAssets('main');
    }

    event.waitUntil(installing);
  });

  self.addEventListener('activate', function (event) {
    console.log('[SW]:', 'Activate event');

    var activation = cacheAdditional();

    // Delete all assets which name starts with CACHE_PREFIX and
    // is not current cache (CACHE_NAME)
    activation = activation.then(storeCacheData);
    activation = activation.then(deleteObsolete);
    activation = activation.then(function () {
      if (self.clients && self.clients.claim) {
        return self.clients.claim();
      }
    });

    event.waitUntil(activation);
  });

  function cacheAdditional() {
    if (!assets.additional.length) {
      return Promise.resolve();
    }

    if (DEBUG) {
      console.log('[SW]:', 'Caching additional');
    }

    var operation = undefined;

    if (strategy === 'changed') {
      operation = cacheChanged('additional');
    } else {
      operation = cacheAssets('additional');
    }

    // Ignore fail of `additional` cache section
    return operation['catch'](function (e) {
      console.error('[SW]:', 'Cache section `additional` failed to load');
    });
  }

  function cacheAssets(section) {
    var batch = assets[section];

    return caches.open(CACHE_NAME).then(function (cache) {
      return addAllNormalized(cache, batch, {
        bust: params.version,
        request: params.prefetchRequest
      });
    }).then(function () {
      logGroup('Cached assets: ' + section, batch);
    })['catch'](function (e) {
      console.error(e);
      throw e;
    });
  }

  function cacheChanged(section) {
    return getLastCache().then(function (args) {
      if (!args) {
        return cacheAssets(section);
      }

      var lastCache = args[0];
      var lastKeys = args[1];
      var lastData = args[2];

      var lastMap = lastData.hashmap;
      var lastVersion = lastData.version;

      if (!lastData.hashmap || lastVersion === params.version) {
        return cacheAssets(section);
      }

      var lastHashedAssets = Object.keys(lastMap).map(function (hash) {
        return lastMap[hash];
      });

      var lastUrls = lastKeys.map(function (req) {
        var url = new URL(req.url);
        url.search = '';
        url.hash = '';

        return url.toString();
      });

      var sectionAssets = assets[section];
      var moved = [];
      var changed = sectionAssets.filter(function (url) {
        if (lastUrls.indexOf(url) === -1 || lastHashedAssets.indexOf(url) === -1) {
          return true;
        }

        return false;
      });

      Object.keys(hashesMap).forEach(function (hash) {
        var asset = hashesMap[hash];

        // Return if not in sectionAssets or in changed or moved array
        if (sectionAssets.indexOf(asset) === -1 || changed.indexOf(asset) !== -1 || moved.indexOf(asset) !== -1) return;

        var lastAsset = lastMap[hash];

        if (lastAsset && lastUrls.indexOf(lastAsset) !== -1) {
          moved.push([lastAsset, asset]);
        } else {
          changed.push(asset);
        }
      });

      logGroup('Changed assets: ' + section, changed);
      logGroup('Moved assets: ' + section, moved);

      var movedResponses = Promise.all(moved.map(function (pair) {
        return lastCache.match(pair[0]).then(function (response) {
          return [pair[1], response];
        });
      }));

      return caches.open(CACHE_NAME).then(function (cache) {
        var move = movedResponses.then(function (responses) {
          return Promise.all(responses.map(function (pair) {
            return cache.put(pair[0], pair[1]);
          }));
        });

        return Promise.all([move, addAllNormalized(cache, changed, {
          bust: params.version,
          request: params.prefetchRequest
        })]);
      });
    });
  }

  function deleteObsolete() {
    return caches.keys().then(function (keys) {
      var all = keys.map(function (key) {
        if (key.indexOf(CACHE_PREFIX) !== 0 || key.indexOf(CACHE_NAME) === 0) return;

        console.log('[SW]:', 'Delete cache:', key);
        return caches['delete'](key);
      });

      return Promise.all(all);
    });
  }

  function getLastCache() {
    return caches.keys().then(function (keys) {
      var index = keys.length;
      var key = undefined;

      while (index--) {
        key = keys[index];

        if (key.indexOf(CACHE_PREFIX) === 0) {
          break;
        }
      }

      if (!key) return;

      var cache = undefined;

      return caches.open(key).then(function (_cache) {
        cache = _cache;
        return _cache.match(new URL(STORED_DATA_KEY, location).toString());
      }).then(function (response) {
        if (!response) return;

        return Promise.all([cache, cache.keys(), response.json()]);
      });
    });
  }

  function storeCacheData() {
    return caches.open(CACHE_NAME).then(function (cache) {
      var data = new Response(JSON.stringify({
        version: params.version,
        hashmap: hashesMap
      }));

      return cache.put(new URL(STORED_DATA_KEY, location).toString(), data);
    });
  }

  self.addEventListener('fetch', function (event) {
    var url = new URL(event.request.url);
    url.hash = '';

    var urlString = url.toString();

    // Not external, so search part of the URL should be stripped,
    // if it's external URL, the search part should be kept
    if (externals.indexOf(urlString) === -1) {
      url.search = '';
      urlString = url.toString();
    }

    // Handle only GET requests
    var isGET = event.request.method === 'GET';
    var assetMatches = allAssets.indexOf(urlString) !== -1;
    var cacheUrl = urlString;

    if (!assetMatches) {
      var cacheRewrite = matchCacheMap(event.request);

      if (cacheRewrite) {
        cacheUrl = cacheRewrite;
        assetMatches = true;
      }
    }

    if (!assetMatches && isGET) {
      // If isn't a cached asset and is a navigation request,
      // fallback to navigateFallbackURL if available
      if (navigateFallbackURL && isNavigateRequest(event.request)) {
        event.respondWith(handleNavigateFallback(fetch(event.request)));

        return;
      }
    }

    if (!assetMatches || !isGET) {
      // Fix for https://twitter.com/wanderview/status/696819243262873600
      if (url.origin !== location.origin && navigator.userAgent.indexOf('Firefox/44.') !== -1) {
        event.respondWith(fetch(event.request));
      }

      return;
    }

    // Logic of caching / fetching is here
    // * urlString -- url to match from the CACHE_NAME
    // * event.request -- original Request to perform fetch() if necessary
    var resource = undefined;

    if (responseStrategy === 'network-first') {
      resource = networkFirstResponse(event, urlString, cacheUrl);
    }
    // 'cache-first'
    // (responseStrategy has been validated before)
    else {
        resource = cacheFirstResponse(event, urlString, cacheUrl);
      }

    if (navigateFallbackURL && isNavigateRequest(event.request)) {
      resource = handleNavigateFallback(resource);
    }

    event.respondWith(resource);
  });

  self.addEventListener('message', function (e) {
    var data = e.data;
    if (!data) return;

    switch (data.action) {
      case 'skipWaiting':
        {
          if (self.skipWaiting) self.skipWaiting();
        }break;
    }
  });

  function cacheFirstResponse(event, urlString, cacheUrl) {
    return cachesMatch(cacheUrl, CACHE_NAME).then(function (response) {
      if (response) {
        if (DEBUG) {
          console.log('[SW]:', 'URL [' + cacheUrl + '](' + urlString + ') from cache');
        }

        return response;
      }

      // Load and cache known assets
      var fetching = fetch(event.request).then(function (response) {
        if (!response.ok) {
          if (DEBUG) {
            console.log('[SW]:', 'URL [' + urlString + '] wrong response: [' + response.status + '] ' + response.type);
          }

          return response;
        }

        if (DEBUG) {
          console.log('[SW]:', 'URL [' + urlString + '] from network');
        }

        if (cacheUrl === urlString) {
          (function () {
            var responseClone = response.clone();
            var storing = caches.open(CACHE_NAME).then(function (cache) {
              return cache.put(urlString, responseClone);
            }).then(function () {
              console.log('[SW]:', 'Cache asset: ' + urlString);
            });

            event.waitUntil(storing);
          })();
        }

        return response;
      });

      return fetching;
    });
  }

  function networkFirstResponse(event, urlString, cacheUrl) {
    return fetch(event.request).then(function (response) {
      if (response.ok) {
        if (DEBUG) {
          console.log('[SW]:', 'URL [' + urlString + '] from network');
        }

        return response;
      }

      // Throw to reach the code in the catch below
      throw new Error('Response is not ok');
    })
    // This needs to be in a catch() and not just in the then() above
    // cause if your network is down, the fetch() will throw
    ['catch'](function () {
      if (DEBUG) {
        console.log('[SW]:', 'URL [' + urlString + '] from cache if possible');
      }

      return cachesMatch(cacheUrl, CACHE_NAME);
    });
  }

  function handleNavigateFallback(fetching) {
    return fetching['catch'](function () {}).then(function (response) {
      var isOk = response && response.ok;
      var isRedirect = response && response.type === 'opaqueredirect';

      if (isOk || isRedirect && !navigateFallbackForRedirects) {
        return response;
      }

      if (DEBUG) {
        console.log('[SW]:', 'Loading navigation fallback [' + navigateFallbackURL + '] from cache');
      }

      return cachesMatch(navigateFallbackURL, CACHE_NAME);
    });
  }

  function mapAssets() {
    Object.keys(assets).forEach(function (key) {
      assets[key] = assets[key].map(function (path) {
        var url = new URL(path, location);

        url.hash = '';

        if (externals.indexOf(path) === -1) {
          url.search = '';
        }

        return url.toString();
      });
    });

    Object.keys(loadersMap).forEach(function (key) {
      loadersMap[key] = loadersMap[key].map(function (path) {
        var url = new URL(path, location);

        url.hash = '';

        if (externals.indexOf(path) === -1) {
          url.search = '';
        }

        return url.toString();
      });
    });

    hashesMap = Object.keys(hashesMap).reduce(function (result, hash) {
      var url = new URL(hashesMap[hash], location);
      url.search = '';
      url.hash = '';

      result[hash] = url.toString();
      return result;
    }, {});

    externals = externals.map(function (path) {
      var url = new URL(path, location);
      url.hash = '';

      return url.toString();
    });
  }

  function addAllNormalized(cache, requests, options) {
    var allowLoaders = options.allowLoaders !== false;
    var bustValue = options && options.bust;
    var requestInit = options.request || {
      credentials: 'omit',
      mode: 'cors'
    };

    return Promise.all(requests.map(function (request) {
      if (bustValue) {
        request = applyCacheBust(request, bustValue);
      }

      return fetch(request, requestInit).then(fixRedirectedResponse);
    })).then(function (responses) {
      if (responses.some(function (response) {
        return !response.ok;
      })) {
        return Promise.reject(new Error('Wrong response status'));
      }

      var extracted = [];
      var addAll = responses.map(function (response, i) {
        if (allowLoaders) {
          extracted.push(extractAssetsWithLoaders(requests[i], response));
        }

        return cache.put(requests[i], response);
      });

      if (extracted.length) {
        (function () {
          var newOptions = copyObject(options);
          newOptions.allowLoaders = false;

          var waitAll = addAll;

          addAll = Promise.all(extracted).then(function (all) {
            var extractedRequests = [].concat.apply([], all);

            if (requests.length) {
              waitAll = waitAll.concat(addAllNormalized(cache, extractedRequests, newOptions));
            }

            return Promise.all(waitAll);
          });
        })();
      } else {
        addAll = Promise.all(addAll);
      }

      return addAll;
    });
  }

  function extractAssetsWithLoaders(request, response) {
    var all = Object.keys(loadersMap).map(function (key) {
      var loader = loadersMap[key];

      if (loader.indexOf(request) !== -1 && loaders[key]) {
        return loaders[key](response.clone());
      }
    }).filter(function (a) {
      return !!a;
    });

    return Promise.all(all).then(function (all) {
      return [].concat.apply([], all);
    });
  }

  function matchCacheMap(request) {
    var urlString = request.url;
    var url = new URL(urlString);

    var requestType = undefined;

    if (request.mode === 'navigate') {
      requestType = 'navigate';
    } else if (url.origin === location.origin) {
      requestType = 'same-origin';
    } else {
      requestType = 'cross-origin';
    }

    for (var i = 0; i < cacheMaps.length; i++) {
      var map = cacheMaps[i];

      if (!map) continue;
      if (map.requestTypes && map.requestTypes.indexOf(requestType) === -1) {
        continue;
      }

      var newString = undefined;

      if (typeof map.match === 'function') {
        newString = map.match(url, request);
      } else {
        newString = urlString.replace(map.match, map.to);
      }

      if (newString && newString !== urlString) {
        return newString;
      }
    }
  }
}

function cachesMatch(request, cacheName) {
  return caches.match(request, {
    cacheName: cacheName
  }).then(function (response) {
    if (isNotRedirectedResponse()) {
      return response;
    }

    // Fix already cached redirected responses
    return fixRedirectedResponse(response).then(function (fixedResponse) {
      return caches.open(cacheName).then(function (cache) {
        return cache.put(request, fixedResponse);
      }).then(function () {
        return fixedResponse;
      });
    });
  })
  // Return void if error happened (cache not found)
  ['catch'](function () {});
}

function applyCacheBust(asset, key) {
  var hasQuery = asset.indexOf('?') !== -1;
  return asset + (hasQuery ? '&' : '?') + '__uncache=' + encodeURIComponent(key);
}

function getClientsURLs() {
  if (!self.clients) {
    return Promise.resolve([]);
  }

  return self.clients.matchAll({
    includeUncontrolled: true
  }).then(function (clients) {
    if (!clients.length) return [];

    var result = [];

    clients.forEach(function (client) {
      var url = new URL(client.url);
      url.search = '';
      url.hash = '';
      var urlString = url.toString();

      if (!result.length || result.indexOf(urlString) === -1) {
        result.push(urlString);
      }
    });

    return result;
  });
}

function isNavigateRequest(request) {
  return request.mode === 'navigate' || request.headers.get('Upgrade-Insecure-Requests') || (request.headers.get('Accept') || '').indexOf('text/html') !== -1;
}

function isNotRedirectedResponse(response) {
  return !response || !response.redirected || !response.ok || response.type === 'opaqueredirect';
}

// Based on https://github.com/GoogleChrome/sw-precache/pull/241/files#diff-3ee9060dc7a312c6a822cac63a8c630bR85
function fixRedirectedResponse(response) {
  if (isNotRedirectedResponse(response)) {
    return Promise.resolve(response);
  }

  var body = 'body' in response ? Promise.resolve(response.body) : response.blob();

  return body.then(function (data) {
    return new Response(data, {
      headers: response.headers,
      status: response.status
    });
  });
}

function copyObject(original) {
  return Object.keys(original).reduce(function (result, key) {
    result[key] = original[key];
    return result;
  }, {});
}

function logGroup(title, assets) {
  console.groupCollapsed('[SW]:', title);

  assets.forEach(function (asset) {
    console.log('Asset:', asset);
  });

  console.groupEnd();
}
        WebpackServiceWorker(__wpo, {
loaders: {},
cacheMaps: [],
});
        module.exports = __webpack_require__(1)
      

/***/ }),
/* 1 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__storage_modifier__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__web_push_notifications__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__web_push_notifications___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1__web_push_notifications__);
/*** IMPORTS FROM imports-loader ***/
var process = (process || {});
process.env = {"npm_config_save_dev":"","npm_config_shrinkwrap":"true","npm_config_init_license":"ISC","npm_package_devDependencies_webpack_dev_server":"^2.9.5","npm_package_dependencies_lodash":"^4.17.4","npm_package_dependencies_punycode":"^2.1.0","npm_package_dependencies_throng":"^4.0.0","npm_config_save":"true","npm_package_dependencies_babel_preset_env":"^1.6.1","npm_package_devDependencies_enzyme":"^3.2.0","npm_package_dependencies_http_link_header":"^0.8.0","npm_config_node_gyp":"/usr/lib/node_modules/node-gyp/bin/node-gyp.js","npm_config_link":"","npm_config_timing":"","npm_package_dependencies_is_nan":"^1.2.1","npm_execpath":"/usr/lib/node_modules/npm/bin/npm-cli.js","npm_config_user":"1000","npm_package_dependencies_react_router_dom":"^4.1.1","npm_config_bin_links":"true","npm_package_dependencies_path_complete_extname":"^0.1.0","npm_package_dependencies_marky":"^1.2.0","npm_config_proxy":"","npm_package_dependencies_rails_ujs":"^5.1.2","npm_config_node_options":"","npm_package_dependencies_postcss_object_fit_images":"^1.1.2","npm_config_only":"","npm_package_dependencies_react_router_scroll_4":"^1.0.0-beta.1","npm_package_dependencies_intersection_observer":"^0.5.0","npm_package_dependencies_babel_plugin_react_intl":"^2.3.1","npm_package_dependencies_webpack":"^3.9.1","npm_config_description":"true","npm_config_ignore_prepublish":"","npm_config_editor":"vi","npm_config_tag":"latest","npm_config_global":"","npm_package_dependencies_sass_loader":"^6.0.6","npm_package_dependencies_postcss_loader":"^2.0.9","npm_config_commit_hooks":"true","npm_config_browser":"","npm_package_homepage":"https://github.com/tootsuite/mastodon#readme","npm_config_if_present":"","npm_config_local_address":"","npm_package_repository_url":"git+https://github.com/tootsuite/mastodon.git","npm_config_versions":"","npm_package_devDependencies_eslint":"^4.15.0","npm_config_access":"","npm_config_script_shell":"","npm_package_scripts_start":"node ./streaming/index.js","npm_config_optional":"true","npm_package_dependencies_react_notification":"^6.8.2","npm_package_dependencies_fsevents":"*","npm_config_user_agent":"npm/6.0.1 node/v10.1.0 linux x64","npm_config_init_version":"1.0.0","npm_package_dependencies_react_immutable_proptypes":"^2.1.0","npm_config_registry":"https://registry.npmjs.org/","npm_package_scripts_postversion":"git push --tags","npm_config_init_module":"/home/noyuno/.npm-init.js","npm_package_dependencies_node_sass":"^4.7.2","npm_package_devDependencies_eslint_plugin_import":"^2.8.0","npm_config_sso_poll_frequency":"500","npm_config_strict_ssl":"true","npm_config_sso_type":"oauth","npm_config_loglevel":"notice","npm_package_dependencies_react_motion":"^0.5.2","npm_package_dependencies_dotenv":"^4.0.0","npm_config_save_exact":"","npm_package_dependencies_es6_symbol":"^3.1.1","npm_config_production":"","npm_package_dependencies_axios":"~0.16.2","npm_package_scripts_manage_translations":"node ./config/webpack/translationRunner.js","npm_package_license":"AGPL-3.0-or-later","npm_package_dependencies_object_values":"^1.0.4","npm_package_dependencies_offline_plugin":"^4.8.3","npm_package_dependencies_react_redux":"^5.0.4","npm_package_dependencies_npmlog":"^4.1.2","npm_package_dependencies_glob":"^7.1.1","npm_package_dependencies_webpack_manifest_plugin":"^1.2.1","npm_config_allow_same_version":"","npm_config_userconfig":"/home/noyuno/.npmrc","npm_lifecycle_event":"build","npm_config_depth":"Infinity","npm_package_optionalDependencies_fsevents":"*","npm_config_searchexclude":"","npm_config_umask":"0022","npm_config_onload_script":"","npm_package_devDependencies_eslint_plugin_react":"^7.5.1","npm_package_dependencies_babel_plugin_transform_es2015_modules_commonjs":"^6.24.1","npm_config_shell":"bash","npm_package_dependencies_babel_plugin_transform_react_remove_prop_types":"^0.4.10","npm_config_no_proxy":"","npm_package_description":"mastodon","npm_config_logs_max":"10","npm_package_dependencies_reselect":"^3.0.1","npm_config_searchlimit":"20","PWD":"/home/noyuno/mastofe","npm_config_cidr":"","npm_config_node_version":"10.1.0","npm_package_dependencies_babel_core":"^6.25.0","npm_config_searchopts":"","npm_package_dependencies_intl_messageformat":"^2.2.0","npm_config_unicode":"","HOME":"/home/noyuno","npm_config_group":"1000","npm_config_cache_min":"10","npm_config_cache":"/home/noyuno/.npm","npm_config_save_optional":"","npm_config_init_author_name":"","npm_package_gitHead":"6ad323da5fb11d281ff307d8c76f054e30a5c1b4","npm_package_dependencies_compression_webpack_plugin":"^1.0.1","npm_package_devDependencies_jest":"^21.2.1","npm_package_dependencies_rimraf":"^2.6.1","npm_package_devDependencies_yargs":"^8.0.2","npm_config_always_auth":"","npm_config_argv":"{\"remain\":[],\"cooked\":[\"run\",\"build\"],\"original\":[\"run\",\"build\"]}","npm_package_dependencies_react_intl":"^2.4.0","npm_config_progress":"true","npm_package_scripts_build":"cross-env NODE_ENV=production webpack --config config/webpack/production.js","npm_config_scripts_prepend_node_path":"warn-only","npm_config_ca":"","npm_package_dependencies_detect_passive_events":"^1.0.2","npm_config_package_lock_only":"","npm_package_scripts_build_development":"cross-env NODE_ENV=development webpack --config config/webpack/development.js","npm_package_dependencies_babel_plugin_transform_decorators_legacy":"^1.3.4","npm_config_init_author_url":"","npm_package_dependencies_requestidlecallback":"^0.3.0","npm_package_dependencies_babel_plugin_transform_runtime":"^6.23.0","npm_config_cache_max":"Infinity","npm_package_dependencies_stringz":"^0.3.0","npm_package_dependencies_cross_env":"^5.1.1","npm_package_scripts_test":"npm-run-all test:lint test:jest","npm_package_dependencies_font_awesome":"^4.7.0","npm_config_cache_lock_wait":"10000","npm_package_dependencies_npm_run_all":"^4.1.2","npm_config_send_metrics":"","npm_package_dependencies_express":"^4.16.2","npm_package_dependencies_emoji_mart":"github:Gargron/emoji-mart#build","npm_package_devDependencies_react_test_renderer":"^16.2.0","npm_package_dependencies_babel_plugin_syntax_dynamic_import":"^6.18.0","npm_package_dependencies_babel_plugin_transform_class_properties":"^6.24.1","npm_package_scripts_dev":"cross-env NODE_ENV=development webpack-dev-server --config config/webpack/development.js --progress --color","npm_package_dependencies_uuid":"^3.1.0","npm_config_cert":"","npm_package_dependencies_tiny_queue":"^0.2.1","npm_config_prefer_online":"","npm_config_global_style":"","npm_package_bugs_url":"https://github.com/tootsuite/mastodon/issues","npm_package_optionalDependencies_node_zopfli":"^2.0.2","npm_package_dependencies_autoprefixer":"^7.1.6","npm_config_tag_version_prefix":"v","npm_package_devDependencies_eslint_plugin_promise":"^3.7.0","npm_config_otp":"","npm_package_dependencies_mark_loader":"^0.1.6","npm_package_dependencies_mkdirp":"^0.5.1","npm_config_ignore_scripts":"","npm_package_dependencies_react_textarea_autosize":"^5.2.1","npm_package_dependencies_webpack_bundle_analyzer":"^2.9.1","npm_config_dry_run":"","npm_config_usage":"","npm_config_parseable":"","npm_config_metrics_registry":"https://registry.npmjs.org/","npm_package_dependencies_style_loader":"^0.19.0","npm_package_dependencies_js_yaml":"^3.9.0","npm_config_globalconfig":"/home/noyuno/.npm/etc/npmrc","npm_package_dependencies_webpack_merge":"^4.1.1","npm_config_cache_lock_retries":"10","npm_config_cafile":"","npm_config_fetch_retry_mintimeout":"10000","npm_config_ham_it_up":"","npm_package_dependencies_redux_immutable":"^4.0.0","npm_package_dependencies_substring_trie":"^1.0.2","npm_package_dependencies_classnames":"^2.2.5","npm_config_version":"","npm_lifecycle_script":"cross-env NODE_ENV=production webpack --config config/webpack/production.js","npm_config_git":"git","npm_package_dependencies_redis":"^2.7.1","npm_config_legacy_bundling":"","npm_config_viewer":"man","npm_package_dependencies_redux":"^3.7.1","INIT_CWD":"/home/noyuno/mastofe","npm_package_dependencies_immutable":"^3.8.2","npm_package_dependencies_extract_text_webpack_plugin":"^3.0.2","npm_config_git_tag_version":"true","npm_package_dependencies_react_dom":"^16.3.0","npm_package_dependencies_prop_types":"^15.5.10","npm_package_dependencies_intl":"^1.2.5","npm_config_https_proxy":"","npm_package_dependencies_redux_thunk":"^2.2.0","npm_config_save_prod":"","npm_config_fetch_retry_maxtimeout":"60000","npm_package_dependencies_object_assign":"^4.1.1","npm_package_dependencies_babel_plugin_lodash":"^3.3.2","npm_package_dependencies_react_immutable_pure_component":"^1.1.1","npm_package_dependencies_babel_preset_react":"^6.24.1","npm_config_sign_git_tag":"","npm_config_long":"","npm_package_dependencies_react_swipeable_views":"^0.12.3","npm_package_private":"true","npm_package_dependencies_babel_loader":"^7.1.1","npm_config_message":"%s","npm_config_key":"","npm_package_dependencies_babel_plugin_transform_react_inline_elements":"^6.22.0","npm_package_dependencies_precss":"^2.0.0","npm_package_dependencies_escape_html":"^1.0.3","npm_package_dependencies_css_loader":"^0.28.4","npm_package_engines_node":">=6","npm_config_rebuild_bundle":"true","SHLVL":"1","npm_config_fetch_retry_factor":"10","npm_config_prefer_offline":"","npm_package_dependencies_postcss_smart_import":"^0.7.5","npm_package_dependencies_pg":"^6.4.0","npm_package_dependencies_babel_plugin_transform_object_rest_spread":"^6.23.0","npm_node_execpath":"/usr/bin/node","npm_config_prefix":"/home/noyuno/.npm","npm_config_also":"","npm_config_maxsockets":"50","npm_config_init_author_email":"","npm_config_fetch_retries":"2","npm_package_scripts_test_lint":"eslint -c .eslintrc.yml --ext=js app/javascript/ config/webpack/ streaming/","npm_package_devDependencies_eslint_plugin_jsx_a11y":"^5.1.1","npm_package_dependencies_babel_plugin_transform_react_jsx_self":"^6.22.0","npm_package_dependencies_file_loader":"^0.11.2","npm_package_dependencies_uws":"^8.14.0","npm_package_dependencies_object_fit_images":"^3.2.3","npm_config_json":"","npm_package_dependencies_resolve_url_loader":"^2.2.0","npm_package_dependencies_imports_loader":"^0.8.0","npm_package_repository_type":"git","npm_package_version":"","npm_package_dependencies_babel_plugin_preval":"^1.6.1","npm_package_dependencies_react":"^16.3.0","npm_config_save_bundle":"","npm_config_tmp":"/tmp","npm_package_dependencies_react_redux_loading_bar":"^2.9.3","npm_config_rollback":"true","npm_config_globalignorefile":"/home/noyuno/.npm/etc/npmignore","npm_package_dependencies_react_hotkeys":"^0.10.0","npm_package_dependencies_react_toggle":"^4.0.1","npm_config_read_only":"","npm_config_offline":"","PATH":"/usr/lib/node_modules/npm/node_modules/npm-lifecycle/node-gyp-bin:/home/noyuno/mastofe/node_modules/.bin:/home/noyuno/.rbenv/shims:/home/noyuno/perl5/bin:/home/noyuno/.npm/bin:/home/noyuno/go/bin:/home/noyuno/.password-store/bin:/home/noyuno/.gem/ruby/2.5.0/bin:/home/noyuno/.gem/ruby/2.4.0/bin:/home/noyuno/dotfiles/arch/bin:/home/noyuno/dotfiles/bin:/home/noyuno/.local/bin:/home/noyuno/bin:/home/noyuno/.rbenv/shims:/home/noyuno/perl5/bin:/usr/local/bin:/usr/bin:/bin:/usr/local/sbin:/usr/lib/jvm/default/bin:/usr/bin/site_perl:/usr/bin/vendor_perl:/usr/bin/core_perl:/home/noyuno/.antigen/bundles/zsh-users/zsh-syntax-highlighting:/home/noyuno/.antigen/bundles/zsh-users/zsh-completions:/home/noyuno/.antigen/bundles/zsh-users/zsh-autosuggestions:/home/noyuno/.antigen/bundles/mollifier/cd-gitroot","npm_config_engine_strict":"","npm_config_searchstaleness":"900","npm_package_devDependencies_raf":"^3.4.0","npm_config_save_prefix":"^","npm_config_color":"true","npm_package_scripts_build_production":"cross-env NODE_ENV=production webpack --config config/webpack/production.js","npm_config_scope":"","npm_config_unsafe_perm":"true","NODE":"/usr/bin/node","npm_config_audit":"true","npm_package_readmeFilename":"README.md","npm_package_dependencies_babel_plugin_transform_react_jsx_source":"^6.22.0","npm_package_devDependencies_enzyme_adapter_react_16":"^1.1.0","npm_package_dependencies_array_includes":"^3.0.3","npm_package_dependencies_node_zopfli":"^2.0.2","npm_package_dependencies_intl_relativeformat":"^2.1.0","npm_config_heading":"npm","npm_package_dependencies_react_overlays":"^0.8.3","npm_package_devDependencies_react_intl_translations_manager":"^5.0.0","npm_package_dependencies_websocket_js":"^0.1.12","npm_config_auth_type":"legacy","npm_package_name":"mastodon","npm_config_force":"","npm_config_dev":"","npm_package_devDependencies_babel_eslint":"^8.2.1","npm_config_cache_lock_stale":"60000","npm_package_scripts_test_jest":"cross-env NODE_ENV=test jest --coverage","npm_config_package_lock":"true","_":"/home/noyuno/mastofe/node_modules/.bin/cross-env","NODE_ENV":"production"};




function openSystemCache() {
  return caches.open('mastodon-system');
}

function openWebCache() {
  return caches.open('mastodon-web');
}

function fetchRoot() {
  return fetch('/web', { credentials: 'include' });
}

// Cause a new version of a registered Service Worker to replace an existing one
// that is already installed, and replace the currently active worker on open pages.
self.addEventListener('install', function (event) {
  event.waitUntil(Promise.all([openWebCache(), fetchRoot()]).then(function (_ref) {
    var cache = _ref[0],
        root = _ref[1];
    return cache.put('/web', root);
  }));
});
self.addEventListener('activate', function (event) {
  event.waitUntil(self.clients.claim());
});
self.addEventListener('fetch', function (event) {
  var url = new URL(event.request.url);

  if (url.pathname.startsWith('/web')) {
    // we always make /web/login go through
    if (url.pathname.startsWith('/web/login')) {
      return;
    }
    var asyncResponse = fetchRoot();
    var asyncCache = openWebCache();

    event.respondWith(asyncResponse.then(async function (response) {
      // response was redirected - let's actually do the request from the event
      // and return its response
      if (response.redirected || response.type === 'opaqueredirect') {
        return await fetch(event.request);
      }
      if (response.ok) {
        var cache = await asyncCache;
        await cache.put('/web', response);
        return response.clone();
      }

      throw null;
    }).catch(function () {
      return asyncCache.then(function (cache) {
        return cache.match('/web');
      });
    }));
  } else if (url.pathname === '/auth/sign_out') {
    var _asyncResponse = fetch(event.request);
    var _asyncCache = openWebCache();

    event.respondWith(_asyncResponse.then(async function (response) {
      if (response.ok || response.type === 'opaqueredirect') {
        await Promise.all([_asyncCache.then(function (cache) {
          return cache.delete('/web');
        }), indexedDB.deleteDatabase('mastodon')]);
      }

      return response;
    }));
  } else if (process.env.CDN_HOST ? url.host === process.env.CDN_HOST : url.pathname.startsWith('/system/')) {
    event.respondWith(openSystemCache().then(async function (cache) {
      var cached = await cache.match(event.request.url);

      if (cached === undefined) {
        var fetched = await fetch(event.request);

        if (fetched.ok) {
          try {
            await cache.put(event.request.url, fetched.clone());
          } finally {
            Object(__WEBPACK_IMPORTED_MODULE_0__storage_modifier__["a" /* freeStorage */])();
          }
        }

        return fetched;
      }

      return cached;
    }));
  }
});


/***/ }),
/* 2 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export evictStatus */
/* unused harmony export evictStatuses */
/* unused harmony export putAccounts */
/* unused harmony export putStatuses */
/* harmony export (immutable) */ __webpack_exports__["a"] = freeStorage;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__db__ = __webpack_require__(3);


var accountAssetKeys = ['avatar', 'avatar_static', 'header', 'header_static'];
var storageMargin = 8388608;
var storeLimit = 1024;

function openCache() {
  // ServiceWorker and Cache API is not available on iOS 11
  // https://webkit.org/status/#specification-service-workers
  return self.caches ? caches.open('mastodon-system') : Promise.reject();
}

function printErrorIfAvailable(error) {
  if (error) {
    console.warn(error);
  }
}

function put(name, objects, onupdate, oncreate) {
  return Object(__WEBPACK_IMPORTED_MODULE_0__db__["a" /* default */])().then(function (db) {
    return new Promise(function (resolve, reject) {
      var putTransaction = db.transaction(name, 'readwrite');
      var putStore = putTransaction.objectStore(name);
      var putIndex = putStore.index('id');

      objects.forEach(function (object) {
        putIndex.getKey(object.id).onsuccess = function (retrieval) {
          function addObject() {
            putStore.add(object);
          }

          function deleteObject() {
            putStore.delete(retrieval.target.result).onsuccess = addObject;
          }

          if (retrieval.target.result) {
            if (onupdate) {
              onupdate(object, retrieval.target.result, putStore, deleteObject);
            } else {
              deleteObject();
            }
          } else {
            if (oncreate) {
              oncreate(object, addObject);
            } else {
              addObject();
            }
          }
        };
      });

      putTransaction.oncomplete = function () {
        var readTransaction = db.transaction(name, 'readonly');
        var readStore = readTransaction.objectStore(name);
        var count = readStore.count();

        count.onsuccess = function () {
          var excess = count.result - storeLimit;

          if (excess > 0) {
            var retrieval = readStore.getAll(null, excess);

            retrieval.onsuccess = function () {
              return resolve(retrieval.result);
            };
            retrieval.onerror = reject;
          } else {
            resolve([]);
          }
        };

        count.onerror = reject;
      };

      putTransaction.onerror = reject;
    }).then(function (resolved) {
      db.close();
      return resolved;
    }, function (error) {
      db.close();
      throw error;
    });
  });
}

function evictAccountsByRecords(records) {
  return Object(__WEBPACK_IMPORTED_MODULE_0__db__["a" /* default */])().then(function (db) {
    var transaction = db.transaction(['accounts', 'statuses'], 'readwrite');
    var accounts = transaction.objectStore('accounts');
    var accountsIdIndex = accounts.index('id');
    var accountsMovedIndex = accounts.index('moved');
    var statuses = transaction.objectStore('statuses');
    var statusesIndex = statuses.index('account');

    function evict(toEvict) {
      toEvict.forEach(function (record) {
        openCache().then(function (cache) {
          return accountAssetKeys.forEach(function (key) {
            return cache.delete(records[key]);
          });
        }).catch(printErrorIfAvailable);

        accountsMovedIndex.getAll(record.id).onsuccess = function (_ref) {
          var target = _ref.target;
          return evict(target.result);
        };

        statusesIndex.getAll(record.id).onsuccess = function (_ref2) {
          var target = _ref2.target;
          return evictStatusesByRecords(target.result);
        };

        accountsIdIndex.getKey(record.id).onsuccess = function (_ref3) {
          var target = _ref3.target;
          return target.result && accounts.delete(target.result);
        };
      });
    }

    evict(records);

    db.close();
  }).catch(printErrorIfAvailable);
}

function evictStatus(id) {
  evictStatuses([id]);
}

function evictStatuses(ids) {
  return Object(__WEBPACK_IMPORTED_MODULE_0__db__["a" /* default */])().then(function (db) {
    var transaction = db.transaction('statuses', 'readwrite');
    var store = transaction.objectStore('statuses');
    var idIndex = store.index('id');
    var reblogIndex = store.index('reblog');

    ids.forEach(function (id) {
      reblogIndex.getAllKeys(id).onsuccess = function (_ref4) {
        var target = _ref4.target;
        return target.result.forEach(function (reblogKey) {
          return store.delete(reblogKey);
        });
      };

      idIndex.getKey(id).onsuccess = function (_ref5) {
        var target = _ref5.target;
        return target.result && store.delete(target.result);
      };
    });

    db.close();
  }).catch(printErrorIfAvailable);
}

function evictStatusesByRecords(records) {
  return evictStatuses(records.map(function (_ref6) {
    var id = _ref6.id;
    return id;
  }));
}

function putAccounts(records, avatarStatic) {
  var avatarKey = avatarStatic ? 'avatar_static' : 'avatar';
  var newURLs = [];

  put('accounts', records, function (newRecord, oldKey, store, oncomplete) {
    store.get(oldKey).onsuccess = function (_ref7) {
      var target = _ref7.target;

      accountAssetKeys.forEach(function (key) {
        var newURL = newRecord[key];
        var oldURL = target.result[key];

        if (newURL !== oldURL) {
          openCache().then(function (cache) {
            return cache.delete(oldURL);
          }).catch(printErrorIfAvailable);
        }
      });

      var newURL = newRecord[avatarKey];
      var oldURL = target.result[avatarKey];

      if (newURL !== oldURL) {
        newURLs.push(newURL);
      }

      oncomplete();
    };
  }, function (newRecord, oncomplete) {
    newURLs.push(newRecord[avatarKey]);
    oncomplete();
  }).then(function (records) {
    return Promise.all([evictAccountsByRecords(records), openCache().then(function (cache) {
      return cache.addAll(newURLs);
    })]);
  }).then(freeStorage, function (error) {
    freeStorage();
    throw error;
  }).catch(printErrorIfAvailable);
}

function putStatuses(records) {
  put('statuses', records).then(evictStatusesByRecords).catch(printErrorIfAvailable);
}

function freeStorage() {
  return navigator.storage.estimate().then(function (_ref8) {
    var quota = _ref8.quota,
        usage = _ref8.usage;

    if (usage + storageMargin < quota) {
      return null;
    }

    return Object(__WEBPACK_IMPORTED_MODULE_0__db__["a" /* default */])().then(function (db) {
      return new Promise(function (resolve, reject) {
        var retrieval = db.transaction('accounts', 'readonly').objectStore('accounts').getAll(null, 1);

        retrieval.onsuccess = function () {
          if (retrieval.result.length > 0) {
            resolve(evictAccountsByRecords(retrieval.result).then(freeStorage));
          } else {
            resolve(caches.delete('mastodon-system'));
          }
        };

        retrieval.onerror = reject;

        db.close();
      });
    });
  });
}

/***/ }),
/* 3 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = (function () {
  return new Promise(function (resolve, reject) {
    // ServiceWorker is required to synchronize the login state.
    // Microsoft Edge 17 does not support getAll according to:
    // Catalog of standard and vendor APIs across browsers - Microsoft Edge Development
    // https://developer.microsoft.com/en-us/microsoft-edge/platform/catalog/?q=specName%3Aindexeddb
    if (!('caches' in self && 'getAll' in IDBObjectStore.prototype)) {
      reject();
      return;
    }

    var request = indexedDB.open('mastodon');

    request.onerror = reject;
    request.onsuccess = function (_ref) {
      var target = _ref.target;
      return resolve(target.result);
    };

    request.onupgradeneeded = function (_ref2) {
      var target = _ref2.target;

      var accounts = target.result.createObjectStore('accounts', { autoIncrement: true });
      var statuses = target.result.createObjectStore('statuses', { autoIncrement: true });

      accounts.createIndex('id', 'id', { unique: true });
      accounts.createIndex('moved', 'moved');

      statuses.createIndex('id', 'id', { unique: true });
      statuses.createIndex('account', 'account');
      statuses.createIndex('reblog', 'reblog');
    };
  });
});

/***/ }),
/* 4 */
/***/ (function(module, exports) {

var MAX_NOTIFICATIONS = 5;
var GROUP_TAG = 'tag';

// Avoid loading intl-messageformat and dealing with locales in the ServiceWorker
var formatGroupTitle = function formatGroupTitle(message, count) {
  return message.replace('%{count}', count);
};

var notify = function notify(options) {
  return self.registration.getNotifications().then(function (notifications) {
    if (notifications.length === MAX_NOTIFICATIONS) {
      // Reached the maximum number of notifications, proceed with grouping
      var group = {
        title: formatGroupTitle(options.data.message, notifications.length + 1),
        body: notifications.sort(function (n1, n2) {
          return n1.timestamp < n2.timestamp;
        }).map(function (notification) {
          return notification.title;
        }).join('\n'),
        badge: '/badge.png',
        icon: '/android-chrome-192x192.png',
        tag: GROUP_TAG,
        data: {
          url: new URL('/web/notifications', self.location).href,
          count: notifications.length + 1,
          message: options.data.message
        }
      };

      notifications.forEach(function (notification) {
        return notification.close();
      });

      return self.registration.showNotification(group.title, group);
    } else if (notifications.length === 1 && notifications[0].tag === GROUP_TAG) {
      // Already grouped, proceed with appending the notification to the group
      var _group = cloneNotification(notifications[0]);

      _group.title = formatGroupTitle(_group.data.message, _group.data.count + 1);
      _group.body = options.title + '\n' + _group.body;
      _group.data = Object.assign({}, _group.data, { count: _group.data.count + 1 });

      return self.registration.showNotification(_group.title, _group);
    }

    return self.registration.showNotification(options.title, options);
  });
};

var handlePush = function handlePush(event) {
  var options = event.data.json();

  options.body = options.data.nsfw || options.data.content;
  options.dir = options.data.dir;
  options.image = options.image || undefined; // Null results in a network request (404)
  options.timestamp = options.timestamp && new Date(options.timestamp);

  var expandAction = options.data.actions.find(function (action) {
    return action.todo === 'expand';
  });

  if (expandAction) {
    options.actions = [expandAction];
    options.hiddenActions = options.data.actions.filter(function (action) {
      return action !== expandAction;
    });
    options.data.hiddenImage = options.image;
    options.image = undefined;
  } else {
    options.actions = options.data.actions;
  }

  event.waitUntil(notify(options));
};

var cloneNotification = function cloneNotification(notification) {
  var clone = {};

  for (var k in notification) {
    clone[k] = notification[k];
  }

  return clone;
};

var expandNotification = function expandNotification(notification) {
  var nextNotification = cloneNotification(notification);

  nextNotification.body = notification.data.content;
  nextNotification.image = notification.data.hiddenImage;
  nextNotification.actions = notification.data.actions.filter(function (action) {
    return action.todo !== 'expand';
  });

  return self.registration.showNotification(nextNotification.title, nextNotification);
};

var makeRequest = function makeRequest(notification, action) {
  return fetch(action.action, {
    headers: {
      'Authorization': 'Bearer ' + notification.data.access_token,
      'Content-Type': 'application/json'
    },
    method: action.method,
    credentials: 'include'
  });
};

var findBestClient = function findBestClient(clients) {
  var focusedClient = clients.find(function (client) {
    return client.focused;
  });
  var visibleClient = clients.find(function (client) {
    return client.visibilityState === 'visible';
  });

  return focusedClient || visibleClient || clients[0];
};

var openUrl = function openUrl(url) {
  return self.clients.matchAll({ type: 'window' }).then(function (clientList) {
    if (clientList.length !== 0) {
      var webClients = clientList.filter(function (client) {
        return (/\/web\//.test(client.url)
        );
      });

      if (webClients.length !== 0) {
        var client = findBestClient(webClients);

        var _ref = new URL(url),
            pathname = _ref.pathname;

        if (pathname.startsWith('/web/')) {
          return client.focus().then(function (client) {
            return client.postMessage({
              type: 'navigate',
              path: pathname.slice('/web/'.length - 1)
            });
          });
        }
      } else if ('navigate' in clientList[0]) {
        // Chrome 42-48 does not support navigate
        var _client = findBestClient(clientList);

        return _client.navigate(url).then(function (client) {
          return client.focus();
        });
      }
    }

    return self.clients.openWindow(url);
  });
};

var removeActionFromNotification = function removeActionFromNotification(notification, action) {
  var actions = notification.actions.filter(function (act) {
    return act.action !== action.action;
  });
  var nextNotification = cloneNotification(notification);

  nextNotification.actions = actions;

  return self.registration.showNotification(nextNotification.title, nextNotification);
};

var handleNotificationClick = function handleNotificationClick(event) {
  var reactToNotificationClick = new Promise(function (resolve, reject) {
    if (event.action) {
      var action = event.notification.data.actions.find(function (_ref2) {
        var action = _ref2.action;
        return action === event.action;
      });

      if (action.todo === 'expand') {
        resolve(expandNotification(event.notification));
      } else if (action.todo === 'request') {
        resolve(makeRequest(event.notification, action).then(function () {
          return removeActionFromNotification(event.notification, action);
        }));
      } else {
        reject('Unknown action: ' + action.todo);
      }
    } else {
      event.notification.close();
      resolve(openUrl(event.notification.data.url));
    }
  });

  event.waitUntil(reactToNotificationClick);
};

self.addEventListener('push', handlePush);
self.addEventListener('notificationclick', handleNotificationClick);

/***/ })
/******/ ]);